<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>MyBatis-源码分析-调试环境搭建</title>
    <url>/2020/06/06/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E8%B0%83%E8%AF%95%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/</url>
    <content><![CDATA[<h3 id="依赖工具"><a href="#依赖工具" class="headerlink" title="依赖工具"></a>依赖工具</h3><p>Maven<br>Git<br>JDK<br>IntelliJ IDEA  </p>
<a id="more"></a>
<h3 id="源码拉取"><a href="#源码拉取" class="headerlink" title="源码拉取"></a>源码拉取</h3><p>从官方仓库 <a href="https://github.com/mybatis/mybatis-3" target="_blank" rel="noopener">https://github.com/mybatis/mybatis-3</a> Fork 出属于自己的仓库。为什么要 Fork ？既然开始阅读、调试源码，我们可能会写一些注释，有了自己的仓库，可以进行自由的提交。<br>使用 IntelliJ IDEA 从 Fork 出来的仓库拉取代码。<br>本文使用的 MyBatis 版本为 3.5.0-SNAPSHOT 。<br>因为 MyBatis 是有些年份的框架，所以克隆的过程可能比较慢，耐心等待。</p>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>MyBatis 想要调试，非常方便，只需要打开 org.apache.ibatis.autoconstructor.AutoConstructorTest 单元测试类，任意一个单元测试方法，右键，开始调试即可。<br>当然，考虑到让大家更好的理解 AutoConstructorTest 这个类，下面，我们还是详细解析下。AutoConstructorTest 所在在 autoconstructor 包下，整体结构如下：<br><img src="/.io//01.jpg" alt="01"></p>
<h3 id="mybatis-config-xml"><a href="#mybatis-config-xml" class="headerlink" title="mybatis-config.xml"></a>mybatis-config.xml</h3><p>mybatis-config.xml ，MyBatis 配置文件。XML 如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC <span class="string">"-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line">        <span class="string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- autoMappingBehavior should be set in each test <span class="keyword">case</span> --&gt;</span><br><span class="line"></span><br><span class="line">    &lt;environments <span class="keyword">default</span>=<span class="string">"development"</span>&gt;</span><br><span class="line">        &lt;environment id=<span class="string">"development"</span>&gt;</span><br><span class="line">            &lt;!-- 配置事务管理 --&gt;</span><br><span class="line">            &lt;transactionManager type=<span class="string">"JDBC"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">""</span> value=<span class="string">""</span>/&gt;</span><br><span class="line">            &lt;/transactionManager&gt;</span><br><span class="line">            &lt;!-- 配置数据源  --&gt;</span><br><span class="line">            &lt;dataSource type=<span class="string">"UNPOOLED"</span>&gt;</span><br><span class="line">                &lt;property name=<span class="string">"driver"</span> value=<span class="string">"org.hsqldb.jdbcDriver"</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">"url"</span> value=<span class="string">"jdbc:hsqldb:mem:automapping"</span>/&gt;</span><br><span class="line">                &lt;property name=<span class="string">"username"</span> value=<span class="string">"sa"</span>/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;!-- 扫描 Mapper 文件  --&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=<span class="string">"org/apache/ibatis/autoconstructor/AutoConstructorMapper.xml"</span>/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>在 <environments> 标签中，配置了事务管理和数据源。考虑到减少外部依赖，所以使用了 HSQLDB 。</environments></li>
<li>在 <mappers> 标签中，配置了需要扫描的 Mapper 文件。目前，仅仅扫描 AutoConstructorMapper.xml 文件。  </mappers></li>
</ul>
<h3 id="AutoConstructorMapper-xml"><a href="#AutoConstructorMapper-xml" class="headerlink" title="AutoConstructorMapper.xml"></a>AutoConstructorMapper.xml</h3><p>AutoConstructorMapper.xml ，Mapper 文件。代码如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">    PUBLIC <span class="string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line">    <span class="string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=<span class="string">"org.apache.ibatis.autoconstructor.AutoConstructorMapper"</span>&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>对应的接口为 org.apache.ibatis.autoconstructor.AutoConstructorMapper 。</li>
</ul>
<h4 id="AutoConstructorMapper"><a href="#AutoConstructorMapper" class="headerlink" title="AutoConstructorMapper"></a>AutoConstructorMapper</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">AutoConstructorMapper</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== PrimitiveSubject ==========</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM subject WHERE id = #&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">PrimitiveSubject <span class="title">getSubject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id)</span></span>;</span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM subject"</span>)</span><br><span class="line">    <span class="function">List&lt;PrimitiveSubject&gt; <span class="title">getSubjects</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== AnnotatedSubject ==========</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM subject"</span>)</span><br><span class="line">    <span class="function">List&lt;AnnotatedSubject&gt; <span class="title">getAnnotatedSubjects</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== BadSubject ==========</span></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM subject"</span>)</span><br><span class="line">    <span class="function">List&lt;BadSubject&gt; <span class="title">getBadSubjects</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ========== ExtensiveSubject ==========</span></span><br><span class="line">    <span class="meta">@Select</span>(<span class="string">"SELECT * FROM extensive_subject"</span>)</span><br><span class="line">    <span class="function">List&lt;ExtensiveSubject&gt; <span class="title">getExtensiveSubject</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>使用注解的方法，编写 SQL 。</li>
</ul>
<h3 id="CreateDB-sql"><a href="#CreateDB-sql" class="headerlink" title="CreateDB.sql"></a>CreateDB.sql</h3><p>CreateDB.sql 文件，用于单元测试里，初始化数据库的数据。如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DROP TABLE subject</span><br><span class="line">IF EXISTS;</span><br><span class="line"></span><br><span class="line">DROP TABLE extensive_subject</span><br><span class="line">IF EXISTS;</span><br><span class="line"></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">subject</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  id     INT NOT NULL,</span></span></span><br><span class="line"><span class="function"><span class="params">  name   VARCHAR(<span class="number">20</span>)</span>,</span></span><br><span class="line"><span class="function">  age    INT NOT NULL,</span></span><br><span class="line"><span class="function">  height INT,</span></span><br><span class="line"><span class="function">  weight INT,</span></span><br><span class="line"><span class="function">  active BIT,</span></span><br><span class="line"><span class="function">  dt     TIMESTAMP</span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">CREATE TABLE <span class="title">extensive_subject</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  aByte      TINYINT,</span></span></span><br><span class="line"><span class="function"><span class="params">  aShort     SMALLINT,</span></span></span><br><span class="line"><span class="function"><span class="params">  aChar      CHAR,</span></span></span><br><span class="line"><span class="function"><span class="params">  anInt      INT,</span></span></span><br><span class="line"><span class="function"><span class="params">  aLong      BIGINT,</span></span></span><br><span class="line"><span class="function"><span class="params">  aFloat     FLOAT,</span></span></span><br><span class="line"><span class="function"><span class="params">  aDouble    DOUBLE,</span></span></span><br><span class="line"><span class="function"><span class="params">  aBoolean   BIT,</span></span></span><br><span class="line"><span class="function"><span class="params">  aString    VARCHAR(<span class="number">255</span>)</span>,</span></span><br><span class="line"><span class="function">  anEnum     <span class="title">VARCHAR</span><span class="params">(<span class="number">50</span>)</span>,</span></span><br><span class="line"><span class="function">  aClob      LONGVARCHAR,</span></span><br><span class="line"><span class="function">  aBlob      LONGVARBINARY,</span></span><br><span class="line"><span class="function">  aTimestamp TIMESTAMP</span></span><br><span class="line"><span class="function">)</span>;</span><br><span class="line"></span><br><span class="line">INSERT INTO subject VALUES</span><br><span class="line">  (<span class="number">1</span>, <span class="string">'a'</span>, <span class="number">10</span>, <span class="number">100</span>, <span class="number">45</span>, <span class="number">1</span>, CURRENT_TIMESTAMP),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'b'</span>, <span class="number">10</span>, NULL, <span class="number">45</span>, <span class="number">1</span>, CURRENT_TIMESTAMP),</span><br><span class="line">  (<span class="number">2</span>, <span class="string">'c'</span>, <span class="number">10</span>, NULL, NULL, <span class="number">0</span>, CURRENT_TIMESTAMP);</span><br><span class="line"></span><br><span class="line">INSERT INTO extensive_subject</span><br><span class="line">VALUES</span><br><span class="line">  (<span class="number">1</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1.0</span>, <span class="number">1</span>, <span class="string">'a'</span>, <span class="string">'AVALUE'</span>, <span class="string">'ACLOB'</span>, <span class="string">'aaaaaabbbbbb'</span>, CURRENT_TIMESTAMP),</span><br><span class="line">  (<span class="number">2</span>, <span class="number">2</span>, <span class="string">'b'</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2.0</span>, <span class="number">2</span>, <span class="string">'b'</span>, <span class="string">'BVALUE'</span>, <span class="string">'BCLOB'</span>, <span class="string">'010101010101'</span>, CURRENT_TIMESTAMP),</span><br><span class="line">  (<span class="number">3</span>, <span class="number">3</span>, <span class="string">'c'</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">3.0</span>, <span class="number">3</span>, <span class="string">'c'</span>, <span class="string">'CVALUE'</span>, <span class="string">'CCLOB'</span>, <span class="string">'777d010078da'</span>, CURRENT_TIMESTAMP);</span><br></pre></td></tr></table></figure>
<ul>
<li>创建了 subject 表，并初始化三条数据。</li>
<li>创建了 extensive_subject 表，并初始化三条数据。</li>
</ul>
<h3 id="POJO"><a href="#POJO" class="headerlink" title="POJO"></a>POJO</h3><p>在 AutoConstructorMapper 中，我们可以看到有四个 POJO 类。但是，从 CreateDB.sql 中，实际只有两个表。这个是为什么呢？继续往下看噢。</p>
<h4 id="AnnotatedSubject"><a href="#AnnotatedSubject" class="headerlink" title="AnnotatedSubject"></a>AnnotatedSubject</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.autoconstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.ibatis.annotations.AutomapConstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotatedSubject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedSubject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id, <span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">int</span> age, <span class="keyword">final</span> <span class="keyword">int</span> height, <span class="keyword">final</span> <span class="keyword">int</span> weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AutomapConstructor</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AnnotatedSubject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id, <span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">int</span> age, <span class="keyword">final</span> Integer height, <span class="keyword">final</span> Integer weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.height = height == <span class="keyword">null</span> ? <span class="number">0</span> : height;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight == <span class="keyword">null</span> ? <span class="number">0</span> : weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应 subject 表。<br>@AutomapConstructor 注解，表示 MyBatis 查询后，在创建 AnnotatedSubject 对象，使用该构造方法。<br>实际场景下，非常少使用这个注解，甚至 Google 上资料也不多。</p>
<h5 id="PrimitiveSubject"><a href="#PrimitiveSubject" class="headerlink" title="PrimitiveSubject"></a>PrimitiveSubject</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.autoconstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimitiveSubject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> weight;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> active;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Date dt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PrimitiveSubject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id, <span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">int</span> age, <span class="keyword">final</span> <span class="keyword">int</span> height, <span class="keyword">final</span> <span class="keyword">int</span> weight, <span class="keyword">final</span> <span class="keyword">boolean</span> active, <span class="keyword">final</span> Date dt)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight;</span><br><span class="line">        <span class="keyword">this</span>.active = active;</span><br><span class="line">        <span class="keyword">this</span>.dt = dt;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的也是 subject 表。<br>和 AnnotatedSubject 不同，在其构造方法上，weight 和 height 方法参数的类型是 int ，而不是 Integer 。那么，如果 subject 表中的记录，这两个字段为 NULL 时，会创建 PrimitiveSubject 对象报错。</p>
<h5 id="BadSubject"><a href="#BadSubject" class="headerlink" title="BadSubject"></a>BadSubject</h5><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.autoconstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BadSubject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Height height;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Double weight;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BadSubject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> id, <span class="keyword">final</span> String name, <span class="keyword">final</span> <span class="keyword">int</span> age, <span class="keyword">final</span> Height height, <span class="keyword">final</span> Double weight)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.height = height;</span><br><span class="line">        <span class="keyword">this</span>.weight = weight == <span class="keyword">null</span> ? <span class="number">0</span> : weight;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Height</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>对应的也是 subject 表。</li>
<li>和 AnnotatedSubject 不同，在其构造方法上，height 方法参数的类型是 Height ，而不是 Integer 。因为 MyBatis 无法识别 Height 类，所以会创建 BadSubject 对象报错。</li>
<li>一般情况下，POJO 对象里，不使用基本类型。</li>
</ul>
<h4 id="ExtensiveSubject"><a href="#ExtensiveSubject" class="headerlink" title="ExtensiveSubject"></a>ExtensiveSubject</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> org.apache.ibatis.autoconstructor;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExtensiveSubject</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span> aByte;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">short</span> aShort;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">char</span> aChar;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> anInt;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span> aLong;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> aFloat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">double</span> aDouble;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> aBoolean;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String aString;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// enum types</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TestEnum anEnum;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// array types</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// string to lob types:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String aClob;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String aBlob;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExtensiveSubject</span><span class="params">(<span class="keyword">final</span> <span class="keyword">byte</span> aByte,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> <span class="keyword">short</span> aShort,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> <span class="keyword">char</span> aChar,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> <span class="keyword">int</span> anInt,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> <span class="keyword">long</span> aLong,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> <span class="keyword">float</span> aFloat,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> <span class="keyword">double</span> aDouble,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> <span class="keyword">boolean</span> aBoolean,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> String aString,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> TestEnum anEnum,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> String aClob,</span></span></span><br><span class="line"><span class="function"><span class="params">                            <span class="keyword">final</span> String aBlob)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.aByte = aByte;</span><br><span class="line">        <span class="keyword">this</span>.aShort = aShort;</span><br><span class="line">        <span class="keyword">this</span>.aChar = aChar;</span><br><span class="line">        <span class="keyword">this</span>.anInt = anInt;</span><br><span class="line">        <span class="keyword">this</span>.aLong = aLong;</span><br><span class="line">        <span class="keyword">this</span>.aFloat = aFloat;</span><br><span class="line">        <span class="keyword">this</span>.aDouble = aDouble;</span><br><span class="line">        <span class="keyword">this</span>.aBoolean = aBoolean;</span><br><span class="line">        <span class="keyword">this</span>.aString = aString;</span><br><span class="line">        <span class="keyword">this</span>.anEnum = anEnum;</span><br><span class="line">        <span class="keyword">this</span>.aClob = aClob;</span><br><span class="line">        <span class="keyword">this</span>.aBlob = aBlob;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> TestEnum &#123;</span><br><span class="line">        AVALUE, BVALUE, CVALUE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对应的也是 extensive_subject 表。<br>这是个复杂对象，基本涵盖了各种类型的数据。</p>
<h3 id="AutoConstructorTest"><a href="#AutoConstructorTest" class="headerlink" title="AutoConstructorTest"></a>AutoConstructorTest</h3><p>org.apache.ibatis.autoconstructor.AutoConstructorTest ，单元测试类。</p>
<h4 id="setUp"><a href="#setUp" class="headerlink" title="setUp"></a>setUp</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line"><span class="meta">@BeforeClass</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">// create a SqlSessionFactory</span></span><br><span class="line">    <span class="comment">// 创建 SqlSessionFactory 对象，基于 mybatis-config.xml 配置文件。</span></span><br><span class="line">    <span class="keyword">try</span> (Reader reader = Resources.getResourceAsReader(<span class="string">"org/apache/ibatis/autoconstructor/mybatis-config.xml"</span>)) &#123;</span><br><span class="line">        sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// populate in-memory database</span></span><br><span class="line">    <span class="comment">// 初始化数据到内存数据库，基于 CreateDB.sql SQL 文件。</span></span><br><span class="line">    BaseDataTest.runScript(sqlSessionFactory.getConfiguration().getEnvironment().getDataSource(),</span><br><span class="line">            <span class="string">"org/apache/ibatis/autoconstructor/CreateDB.sql"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建 SqlSessionFactory 对象，基于 mybatis-config.xml 配置文件。<br>初始化数据到内存数据库，基于 CreateDB.sql SQL 文件。</p>
<h4 id="测试方法"><a href="#测试方法" class="headerlink" title="测试方法"></a>测试方法</h4><p>右键任一单元测试方法，愉快的调试起来把。</p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-源码分析-反射模块</title>
    <url>/2020/06/10/MyBatis-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-%E5%8F%8D%E5%B0%84%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>本文，我们来分享 MyBatis 的反射模块，对应 reflection 包。如下图所示：</p>
<a id="more"></a>
<p><img src="/.io//01.jpg" alt="01"><br><code>Java 中的反射虽然功能强大，但对大多数开发人员来说，写出高质量的反射代码还是 有一定难度的。MyBatis 中专门提供了反射模块，该模块对 Java 原生的反射进行了良好的封装，提了更加简洁易用的 API，方便上层使调用，并且对反射操作进行了一系列优化，例如缓存了类的元数据，提高了反射操作的性能。</code></p>
<h3 id="Reflector"><a href="#Reflector" class="headerlink" title="Reflector"></a>Reflector</h3><p>org.apache.ibatis.reflection.Reflector ，反射器，每个 Reflector 对应一个类。Reflector 会缓存反射操作需要的类的信息，例如：构造方法、属性名、setting / getting 方法等等。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Reflector</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 对应的类</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;?&gt; type;</span><br><span class="line">  <span class="comment">// 可读属性数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] readablePropertyNames;</span><br><span class="line">  <span class="comment">// 可写属性数组</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String[] writeablePropertyNames;</span><br><span class="line">  <span class="comment">// 属性对应的 setting 方法的映射 key: 属性名称  value: Invoke对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; setMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 属性对应的 getting 方法的映射 key: 属性名称  value: Invoke对象</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Invoker&gt; getMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 属性对应的 setting 方法的方法参数类型的映射 key 为属性名称  value 为方法参数类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; setTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 属性对应的 getting 方法的返回值类型的映射 key 为属性名称  value 为返回值的类型</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Class&lt;?&gt;&gt; getTypes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 默认构造方法</span></span><br><span class="line">  <span class="keyword">private</span> Constructor&lt;?&gt; defaultConstructor;</span><br><span class="line">  <span class="comment">// 不区分大小写的属性集合</span></span><br><span class="line">  <span class="keyword">private</span> Map&lt;String, String&gt; caseInsensitivePropertyMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">Reflector</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 设置对应的类</span></span><br><span class="line">    type = clazz;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 初始化 defaultConstructor</span></span><br><span class="line">    addDefaultConstructor(clazz);</span><br><span class="line">    <span class="comment">// &lt;2&gt; // 初始化 getMethods 和 getTypes ，通过遍历 getting 方法</span></span><br><span class="line">    addGetMethods(clazz);</span><br><span class="line">    <span class="comment">// &lt;3&gt; // 初始化 setMethods 和 setTypes ，通过遍历 setting 方法。</span></span><br><span class="line">    addSetMethods(clazz);</span><br><span class="line">    <span class="comment">// &lt;4&gt; // 初始化 getMethods + getTypes 和 setMethods + setTypes ，通过遍历 fields 属性。</span></span><br><span class="line">    addFields(clazz);</span><br><span class="line">    <span class="comment">// &lt;5&gt; 初始化 readablePropertyNames、writeablePropertyNames、caseInsensitivePropertyMap 属性</span></span><br><span class="line">    readablePropertyNames = getMethods.keySet().toArray(<span class="keyword">new</span> String[getMethods.keySet().size()]);</span><br><span class="line">    writeablePropertyNames = setMethods.keySet().toArray(<span class="keyword">new</span> String[setMethods.keySet().size()]);</span><br><span class="line">    <span class="keyword">for</span> (String propName : readablePropertyNames) &#123;</span><br><span class="line">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (String propName : writeablePropertyNames) &#123;</span><br><span class="line">      caseInsensitivePropertyMap.put(propName.toUpperCase(Locale.ENGLISH), propName);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 省略一些方法。。。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addDefaultConstructor"><a href="#addDefaultConstructor" class="headerlink" title="addDefaultConstructor"></a>addDefaultConstructor</h4><p>addDefaultConstructor(Class&lt;?&gt; clazz) 方法，查找默认无参构造方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addDefaultConstructor</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获得所有构造方法</span></span><br><span class="line">  Constructor&lt;?&gt;[] consts = clazz.getDeclaredConstructors();</span><br><span class="line">  <span class="keyword">for</span> (Constructor&lt;?&gt; constructor : consts) &#123;</span><br><span class="line">    <span class="comment">// 判断无参的构造方法</span></span><br><span class="line">    <span class="keyword">if</span> (constructor.getParameterTypes().length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultConstructor = constructor;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addGetMethods"><a href="#addGetMethods" class="headerlink" title="addGetMethods"></a>addGetMethods</h4><p>addGetMethods(Class&lt;?&gt; cls) 方法，初始化 getMethods 和 getTypes ，通过遍历 getting 方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addGetMethods</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 属性与其 getting 方法的映射。</span></span><br><span class="line">    Map&lt;String, List&lt;Method&gt;&gt; conflictingGetters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// &lt;2&gt; 获得所有方法</span></span><br><span class="line">    Method[] methods = getClassMethods(cls);</span><br><span class="line">    <span class="comment">// &lt;3&gt; 遍历所有方法</span></span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">      <span class="comment">// &lt;3.1&gt; 参数大于 0 ，说明不是 getting 方法，忽略</span></span><br><span class="line">      <span class="keyword">if</span> (method.getParameterTypes().length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      String name = method.getName();</span><br><span class="line">      <span class="comment">// &lt;3.2&gt; 以 get 和 is 方法名开头，说明是 getting 方法</span></span><br><span class="line">      <span class="keyword">if</span> ((name.startsWith(<span class="string">"get"</span>) &amp;&amp; name.length() &gt; <span class="number">3</span>)</span><br><span class="line">          || (name.startsWith(<span class="string">"is"</span>) &amp;&amp; name.length() &gt; <span class="number">2</span>)) &#123;</span><br><span class="line">        <span class="comment">// &lt;3.3&gt; 获得属性</span></span><br><span class="line">        name = PropertyNamer.methodToProperty(name);</span><br><span class="line">        <span class="comment">// &lt;3.4&gt; 添加到 conflictingGetters 中</span></span><br><span class="line">        addMethodConflict(conflictingGetters, name, method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// &lt;4&gt; 解决 getting 冲突方法</span></span><br><span class="line">    resolveGetterConflicts(conflictingGetters);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>


<h5 id="getClassMethods"><a href="#getClassMethods" class="headerlink" title="getClassMethods"></a>getClassMethods</h5><p>getClassMethods(Class&lt;?&gt; cls)方法，获得所有方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> Method[] getClassMethods(Class&lt;?&gt; cls) &#123;</span><br><span class="line">  <span class="comment">// 每个方法签名与该方法的映射</span></span><br><span class="line">  Map&lt;String, Method&gt; uniqueMethods = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 循环类，类的父类，类的父类的父类，直到父类为 Object</span></span><br><span class="line">  Class&lt;?&gt; currentClass = cls;</span><br><span class="line">  <span class="keyword">while</span> (currentClass != <span class="keyword">null</span> &amp;&amp; currentClass != Object<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 记录当前类定义的方法</span></span><br><span class="line">    addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// we also need to look for interface methods -</span></span><br><span class="line">    <span class="comment">// because the class may be abstract</span></span><br><span class="line">    <span class="comment">// &lt;2&gt; 记录接口中定义的方法</span></span><br><span class="line">    Class&lt;?&gt;[] interfaces = currentClass.getInterfaces();</span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;</span><br><span class="line">      addUniqueMethods(uniqueMethods, anInterface.getMethods());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获得父类</span></span><br><span class="line">    currentClass = currentClass.getSuperclass();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 转换成 Method 数组返回</span></span><br><span class="line">  Collection&lt;Method&gt; methods = uniqueMethods.values();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> methods.toArray(<span class="keyword">new</span> Method[methods.size()]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>&lt;3&gt; 处，会调用 getSignature(Method method) 方法，获得方法签名。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addUniqueMethods</span><span class="params">(Map&lt;String, Method&gt; uniqueMethods, Method[] methods)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (Method currentMethod : methods) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!currentMethod.isBridge()) &#123;</span><br><span class="line">      <span class="comment">// &lt;3&gt; 获得方法签名</span></span><br><span class="line">      String signature = getSignature(currentMethod);</span><br><span class="line">      <span class="comment">// check to see if the method is already known</span></span><br><span class="line">      <span class="comment">// if it is known, then an extended class must have</span></span><br><span class="line">      <span class="comment">// overridden a method</span></span><br><span class="line">      <span class="comment">// 当 uniqueMethods 不存在时，进行添加</span></span><br><span class="line">      <span class="keyword">if</span> (!uniqueMethods.containsKey(signature)) &#123;</span><br><span class="line">        uniqueMethods.put(signature, currentMethod);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="addSetMethods"><a href="#addSetMethods" class="headerlink" title="addSetMethods"></a>addSetMethods</h4><p>addSetMethods(Class&lt;?&gt; cls) 方法，初始化 setMethods 和 setTypes ，通过遍历 setting 方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addSetMethods</span><span class="params">(Class&lt;?&gt; cls)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 属性与其 setting 方法的映射。</span></span><br><span class="line">  Map&lt;String, List&lt;Method&gt;&gt; conflictingSetters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="comment">// 获得所有方法</span></span><br><span class="line">  Method[] methods = getClassMethods(cls);</span><br><span class="line">  <span class="comment">// 遍历所有方法</span></span><br><span class="line">  <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">    String name = method.getName();</span><br><span class="line">    <span class="comment">// &lt;1&gt; 方法名为 set 开头</span></span><br><span class="line">    <span class="comment">// 参数数量为 1</span></span><br><span class="line">    <span class="keyword">if</span> (name.startsWith(<span class="string">"set"</span>) &amp;&amp; name.length() &gt; <span class="number">3</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (method.getParameterTypes().length == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 获得属性</span></span><br><span class="line">        name = PropertyNamer.methodToProperty(name);</span><br><span class="line">        <span class="comment">// 添加到 conflictingSetters 中</span></span><br><span class="line">        addMethodConflict(conflictingSetters, name, method);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// &lt;2&gt; 解决 setting 冲突方法</span></span><br><span class="line">  resolveSetterConflicts(conflictingSetters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="addFields"><a href="#addFields" class="headerlink" title="addFields"></a>addFields</h4><p>addFields(Class&lt;?&gt; clazz) 方法，初始化 getMethods + getTypes 和 setMethods + setTypes ，通过遍历 fields 属性。实际上，它是 addGetMethods(…) 和 #addSetMethods(…) 方法的补充，因为有些 field ，不存在对应的 setting 或 getting 方法，所以直接使用对应的 field ，而不是方法。代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addFields</span><span class="params">(Class&lt;?&gt; clazz)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 获得所有 field</span></span><br><span class="line">  Field[] fields = clazz.getDeclaredFields();</span><br><span class="line">  <span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">    <span class="comment">// &lt;1&gt; 添加到 setMethods 和 setTypes 中</span></span><br><span class="line">    <span class="keyword">if</span> (!setMethods.containsKey(field.getName())) &#123;</span><br><span class="line">      <span class="comment">// issue #379 - removed the check for final because JDK 1.5 allows</span></span><br><span class="line">      <span class="comment">// modification of final fields through reflection (JSR-133). (JGB)</span></span><br><span class="line">      <span class="comment">// pr #16 - final static can only be set by the classloader</span></span><br><span class="line">      <span class="keyword">int</span> modifiers = field.getModifiers();</span><br><span class="line">      <span class="keyword">if</span> (!(Modifier.isFinal(modifiers) &amp;&amp; Modifier.isStatic(modifiers))) &#123;</span><br><span class="line">        addSetField(field);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 添加到 getMethods 和 getTypes 中</span></span><br><span class="line">    <span class="keyword">if</span> (!getMethods.containsKey(field.getName())) &#123;</span><br><span class="line">      addGetField(field);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 递归，处理父类</span></span><br><span class="line">  <span class="keyword">if</span> (clazz.getSuperclass() != <span class="keyword">null</span>) &#123;</span><br><span class="line">    addFields(clazz.getSuperclass());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="ReflectorFactory"><a href="#ReflectorFactory" class="headerlink" title="ReflectorFactory"></a>ReflectorFactory</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ReflectorFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 是否缓存 Reflector 对象</span></span><br><span class="line">  <span class="function"><span class="keyword">boolean</span> <span class="title">isClassCacheEnabled</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="comment">// 设置是否缓存 Reflector 对象</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">setClassCacheEnabled</span><span class="params">(<span class="keyword">boolean</span> classCacheEnabled)</span></span>;</span><br><span class="line">  <span class="comment">// 获取 Reflector 对象</span></span><br><span class="line">  <span class="function">Reflector <span class="title">findForClass</span><span class="params">(Class&lt;?&gt; type)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis-知识汇总</title>
    <url>/2020/06/05/MyBatis-%E7%9F%A5%E8%AF%86%E6%B1%87%E6%80%BB/</url>
    <content><![CDATA[<h3 id="MyBatis-编程步骤"><a href="#MyBatis-编程步骤" class="headerlink" title="MyBatis 编程步骤"></a>MyBatis 编程步骤</h3><ol>
<li>创建 SqlSessionFactory 对象</li>
<li>通过 SqlSessionFactory 获取 SqlSession 对象</li>
<li>通过 SqlSession 获得 Mapper 代理对象</li>
<li>执行成功，则使用 SqlSession 提交事务</li>
<li>执行失败，则使用 SqlSession 回滚事务</li>
<li>最终，关闭会话<a id="more"></a>

</li>
</ol>
<h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和 ${} 的区别是什么？"></a><font color="green">#{}</font>和 <font color="green">${}</font> 的区别是什么？</h3><ul>
<li>${} 是Properties 文件中的变量占位符，它可以用于XML标签属性值和SQL内部，属于字符串替换。例如将 ${driver} 会被静态替换为 <font color="green">com.mysql.jdbc.driver</font><figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"UNPOOLED"</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;driver&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;url&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$</span></span></span><span class="template-variable">&#123;username&#125;</span><span class="xml"><span class="tag"><span class="string">"</span>/&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span></span><br></pre></td></tr></table></figure></li>
<li>${} 也可以对传递进来的参数原样拼接在 SQL 中。代码如下：<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id="getSubject3" parameterType="Integer" resultType="Subject"&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> subject</span><br><span class="line">    <span class="keyword">WHERE</span> id = $&#123;id&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
实际场景下，不推荐这么做。因为，可能有 SQL 注入的风险。</li>
<li>#{} 是 SQL 的参数占位符，Mybatis 会将 SQL 中的 #{} 替换为 ? 号，在 SQL 执行前会使用 PreparedStatement 的参数设置方法，按序给 SQL 的 ? 号占位符设置参数值，比如 ps.setInt(0, parameterValue) 。 所以，#{} 是预编译处理，可以有效防止 SQL 注入，提高系统安全性。</li>
<li>另外，#{} 和 ${} 的取值方式非常方便。例如：#{item.name} 的取值方式，为使用反射从参数对象中，获取 item 对象的 name 属性值，相当于 param.getItem().getName() 。</li>
</ul>
<h3 id="当实体类中的属性名和表中的字段名不一样-，怎么办？"><a href="#当实体类中的属性名和表中的字段名不一样-，怎么办？" class="headerlink" title="当实体类中的属性名和表中的字段名不一样 ，怎么办？"></a>当实体类中的属性名和表中的字段名不一样 ，怎么办？</h3><ul>
<li><p>第一种， 通过在查询的 SQL 语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。代码如下：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">select</span> id=<span class="string">"selectOrder"</span> parameterType=<span class="string">"Integer"</span> resultType=<span class="string">"Order"</span>&gt; </span><br><span class="line">    <span class="keyword">SELECT</span> order_id <span class="keyword">AS</span> id, order_no <span class="keyword">AS</span> orderno, order_price <span class="keyword">AS</span> price </span><br><span class="line">    <span class="keyword">FROM</span> orders </span><br><span class="line">    <span class="keyword">WHERE</span> order_id = <span class="meta">#&#123;id&#125;</span></span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p>这里，还有几点建议：<br>1、数据库的关键字，统一使用大写，例如：SELECT、AS、FROM、WHERE 。<br>2、每 5 个查询字段换一行，保持整齐。<br>3、, 的后面，和 = 的前后，需要有空格，更加清晰。<br>4、SELECT、FROM、WHERE 等，单独一行，高端大气。</p>
</li>
<li><p>第二种，是第一种的特殊情况。大多数场景下，数据库字段名和实体类中的属性名差，主要是前者为 <strong>下划线风格</strong>，后者为<strong>驼峰风格</strong>。在这种情况下，可以直接配置如下，实现自动的下划线转驼峰的功能。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;setting <span class="type">name</span>="logImpl" <span class="keyword">value</span>="LOG4J"/&gt;</span><br><span class="line">    &lt;setting <span class="type">name</span>="mapUnderscoreToCamelCase" <span class="keyword">value</span>="true" /&gt;</span><br><span class="line">&lt;/settings&gt;</span><br></pre></td></tr></table></figure>
<p>也就说，约定大于配置。非常推荐！</p>
</li>
<li><p>第三种，通过 <resultMap> 来映射字段名和实体类属性名的一一对应的关系。代码如下：</resultMap></p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">&lt;resultMap type=<span class="string">"me.gacl.domain.Order"</span> <span class="built_in">id</span>=”OrderResultMap”&gt; </span><br><span class="line">    &lt;!–- 用 <span class="built_in">id</span> 属性来映射主键字段 -–&gt; </span><br><span class="line">    &lt;<span class="built_in">id</span> <span class="keyword">property</span>=<span class="string">"id"</span> column=<span class="string">"order_id"</span>&gt; </span><br><span class="line">    &lt;!–- 用 <span class="literal">result</span> 属性来映射非主键字段，<span class="keyword">property</span> 为实体类属性名，column 为数据表中的属性 -–&gt; </span><br><span class="line">    &lt;<span class="literal">result</span> <span class="keyword">property</span>=<span class="string">"orderNo"</span> column =<span class="string">"order_no"</span> /&gt; </span><br><span class="line">    &lt;<span class="literal">result</span> <span class="keyword">property</span>=<span class="string">"price"</span> column=<span class="string">"order_price"</span> /&gt; </span><br><span class="line">&lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line">&lt;select <span class="built_in">id</span>=<span class="string">"getOrder"</span> parameterType=<span class="string">"Integer"</span> resultMap=<span class="string">"OrderResultMap"</span>&gt;</span><br><span class="line">    SELECT * </span><br><span class="line">    FROM orders </span><br><span class="line">    WHERE order_id = <span class="comment">#&#123;id&#125;</span></span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure></li>
<li><p><em>此处 SELECT * 仅仅作为示例只用，实际场景下，千万千万千万不要这么干。用多少字段，查询多少字段。*</em>  </p>
</li>
</ul>
<h3 id="XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？"><a href="#XML-映射文件中，除了常见的-select-insert-update-delete标-签之外，还有哪些标签？" class="headerlink" title="XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？"></a>XML 映射文件中，除了常见的 select | insert | update | delete标 签之外，还有哪些标签？</h3><p><code>&lt;cache /&gt; 标签，给定命名空间的缓存配置。</code><br><code>&lt;cache-ref /&gt; 标签，其他命名空间缓存配置的引用。</code><br><code>&lt;resultMap &gt; 标签，是最复杂也是最强大的元素，用来描述如何从数据库结果集中来加载对象。</code><br><code>&lt;parameterMap /&gt; 标签，已废弃！老式风格的参数映射。内联参数是首选,这个元素可能在将来被移除，这里不会记录。</code><br><code>&lt;sql /&gt; 标签，可被其他语句引用的可重用语句块。</code><br><code>&lt;include /&gt; 标签，引用 &lt;sql /&gt; 标签的语句。</code><br><code>&lt;selectKey /&gt; 标签，不支持自增的主键生成策略标签。</code><br><code>&lt;if /&gt;</code><br><code>&lt;choose /&gt;、&lt;when /&gt;、&lt;otherwise /&gt;</code><br><code>&lt;trim /&gt;、&lt;where /&gt;、&lt;set /&gt;</code><br><code>&lt;foreach /&gt;</code><br><code>&lt;bind /&gt;</code><br>请参考 <a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html" target="_blank" rel="noopener">MyBatis 官方文档</a></p>
<h3 id="Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？"><a href="#Mybatis-动态-SQL-是做什么的？都有哪些动态-SQL-？能简述一下动态-SQL-的执行原理吗？" class="headerlink" title="Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？"></a>Mybatis 动态 SQL 是做什么的？都有哪些动态 SQL ？能简述一下动态 SQL 的执行原理吗？</h3><p><code>Mybatis 动态 SQL ，可以让我们在 XML 映射文件内，以 XML 标签的形式编写动态 SQL ，完成逻辑判断和动态拼接 SQL 的功能。</code><br><code>Mybatis 提供了 9 种动态 SQL 标签：&lt;if /&gt;、&lt;choose /&gt;、&lt;when /&gt;、&lt;otherwise /&gt;、&lt;trim /&gt;、&lt;where /&gt;、&lt;set /&gt;、&lt;foreach /&gt;、&lt;bind /&gt; 。</code><br><code>其执行原理为，使用 OGNL 的表达式，从 SQL 参数对象中计算表达式的值，根据表达式的值动态拼接 SQL ，以此来完成动态 SQL 的功能。</code></p>
<p>如上的内容，更加详细的话，请看 <a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">《MyBatis 文档 —— 动态 SQL》</a> 文档。</p>
<h3 id="最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？"><a href="#最佳实践中，通常一个-XML-映射文件，都会写一个-Mapper-接口与之对应。请问，这个-Mapper-接口的工作原理是什么？Mapper-接口里的方法，参数不同时，方法能重载吗？" class="headerlink" title="最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？"></a>最佳实践中，通常一个 XML 映射文件，都会写一个 Mapper 接口与之对应。请问，这个 Mapper 接口的工作原理是什么？Mapper 接口里的方法，参数不同时，方法能重载吗？</h3><p>Mapper 接口，对应的关系如下：</p>
<ul>
<li>接口的全限名，就是映射文件中的 “namespace” 的值。</li>
<li>接口的方法名，就是映射文件中 MappedStatement 的 “id” 值。</li>
<li>接口方法内的参数，就是传递给 SQL 的参数。<br>Mapper 接口是没有实现类的，当调用接口方法时，接口全限名 + 方法名拼接字符串作为 key 值，可唯一定位一个对应的 MappedStatement 。举例：com.mybatis3.mappers.StudentDao.findStudentById ，可以唯一找到 “namespace” 为 com.mybatis3.mappers.StudentDao 下面 “id” 为 findStudentById 的 MappedStatement 。</li>
</ul>
<p><code>总结来说，在 Mybatis 中，每一个 &lt;select /&gt;、&lt;insert /&gt;、&lt;update /&gt;、&lt;delete /&gt; 标签，都会被解析为一个 MappedStatement 对象。另外，Mapper 接口的实现类，通过 MyBatis 使用 JDK Proxy 自动生成其代理对象 Proxy ，而代理对象 Proxy 会拦截接口方法，从而“调用”对应的 MappedStatement 方法，最终执行 SQL ，返回执行结果。整体流程如下图：</code></p>
<p><img src="/.io//01.png" alt="01"></p>
<ul>
<li>其中，SqlSession 在调用 Executor 之前，会获得对应的 MappedStatement 方法。例如：DefaultSqlSession#select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) 方法，代码如下：</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><span class="line"><span class="comment">// DefaultSqlSession.java</span></span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void select(String statement, Object parameter, RowBounds rowBounds, ResultHandler handler) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 获得 MappedStatement 对象</span></span><br><span class="line">        MappedStatement ms = configuration.get<span class="constructor">MappedStatement(<span class="params">statement</span>)</span>;</span><br><span class="line">        <span class="comment">// 执行查询</span></span><br><span class="line">        executor.query(ms, wrap<span class="constructor">Collection(<span class="params">parameter</span>)</span>, rowBounds, handler);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        throw <span class="module-access"><span class="module"><span class="identifier">ExceptionFactory</span>.</span></span>wrap<span class="constructor">Exception(<span class="string">"Error querying database.  Cause: "</span> + <span class="params">e</span>, <span class="params">e</span>)</span>;</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">        <span class="module-access"><span class="module"><span class="identifier">ErrorContext</span>.</span></span>instance<span class="literal">()</span>.reset<span class="literal">()</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Mapper 接口里的方法，是不能重载的，因为是全限名 + 方法名的保存和寻找策略。</li>
</ul>
<h3 id="Mapper-接口绑定有几种实现方式，分别是怎么实现的"><a href="#Mapper-接口绑定有几种实现方式，分别是怎么实现的" class="headerlink" title="Mapper 接口绑定有几种实现方式，分别是怎么实现的?"></a>Mapper 接口绑定有几种实现方式，分别是怎么实现的?</h3><p>接口绑定有三种实现方式：</p>
<ul>
<li>第一种，通过 XML Mapper 里面写 SQL 来绑定。在这种情况下，要指定 XML 映射文件里面的 “namespace” 必须为接口的全路径名。</li>
<li>第二种，通过注解绑定，就是在接口的方法上面加上 @Select、@Update、@Insert、@Delete 注解，里面包含 SQL 语句来绑定。</li>
<li>第三种，是第二种的特例，也是通过注解绑定，在接口的方法上面加上 @SelectProvider、@UpdateProvider、@InsertProvider、@DeleteProvider 注解，通过 Java 代码，生成对应的动态 SQL。<br><code>实际场景下，最最最推荐的是第一种方式。因为，SQL 通过注解写在 Java 代码中，会非常杂乱。而写在 XML 中，更加有整体性，并且可以更加方便的使用 OGNL 表达式。</code></li>
</ul>
<h3 id="Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？"><a href="#Mybatis-的-XML-Mapper文件中，不同的-XML-映射文件，id-是否可以重复？" class="headerlink" title="Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？"></a>Mybatis 的 XML Mapper文件中，不同的 XML 映射文件，id 是否可以重复？</h3><p>不同的 XML Mapper 文件，如果配置了 “namespace” ，那么 id 可以重复；如果没有配置 “namespace” ，那么 id 不能重复。毕竟”namespace” 不是必须的，只是最佳实践而已。</p>
<p>原因就是，namespace + id 是作为 Map&lt;String, MappedStatement&gt; 的 key 使用的。如果没有 “namespace”，就剩下 id ，那么 id 重复会导致数据互相覆盖。如果有了 “namespace”，自然 id 就可以重复，”namespace”不同，namespace + id 自然也就不同。</p>
<h3 id="如何获取自动生成的-主-键值"><a href="#如何获取自动生成的-主-键值" class="headerlink" title="如何获取自动生成的(主)键值?"></a>如何获取自动生成的(主)键值?</h3><p>不同的数据库，获取自动生成的(主)键值的方式是不同的。</p>
<p><code>MySQL 有两种方式，但是自增主键，代码如下：</code></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// 方式一，使用 useGeneratedKeys + keyProperty 属性</span><br><span class="line">&lt;<span class="keyword">insert</span> id="insert" parameterType="Person" useGeneratedKeys="true" keyProperty="id"&gt;</span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> person(<span class="type">name</span>, pswd)</span><br><span class="line">    <span class="keyword">VALUE</span> (#&#123;<span class="type">name</span>&#125;, #&#123;pswd&#125;)</span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br><span class="line">    </span><br><span class="line">// 方式二，使用 `&lt;selectKey /&gt;` 标签</span><br><span class="line">&lt;<span class="keyword">insert</span> id="insert" parameterType="Person"&gt;</span><br><span class="line">    &lt;selectKey keyProperty="id" resultType="long" <span class="keyword">order</span>="AFTER"&gt;</span><br><span class="line">        <span class="keyword">SELECT</span> LAST_INSERT_ID()</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">        </span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> person(<span class="type">name</span>, pswd)</span><br><span class="line">    <span class="keyword">VALUE</span> (#&#123;<span class="type">name</span>&#125;, #&#123;pswd&#125;)</span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li>其中，方式一较为常用。</li>
</ul>
<p><code>Oracle 有两种方式，序列和触发器。基于序列，根据 &lt;selectKey /&gt; 执行的时机，也有两种方式，代码如下：</code></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 这个是创建表的自增序列</span></span><br><span class="line">CREATE SEQUENCE student_sequence</span><br><span class="line">INCREMENT BY <span class="number">1</span></span><br><span class="line">NOMAXVALUE</span><br><span class="line">NOCYCLE</span><br><span class="line">CACHE <span class="number">10</span>;</span><br></pre></td></tr></table></figure>
<p>// 方式一，使用 <code>&lt;selectKey /&gt;</code> 标签 + BEFORE</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;insert id=<span class="string">"add"</span> parameterType=<span class="string">"Student"</span>&gt;</span><br><span class="line">　　&lt;selectKey keyProperty=<span class="string">"student_id"</span> resultType=<span class="string">"int"</span> order=<span class="string">"BEFORE"</span>&gt;</span><br><span class="line">      select student_sequence.nextval FROM dual</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    </span><br><span class="line">     <span class="function">INSERT INTO <span class="title">student</span><span class="params">(student_id, student_name, student_age)</span></span></span><br><span class="line"><span class="function">     <span class="title">VALUES</span> <span class="params">(#&#123;student_id&#125;,#&#123;student_name&#125;,#&#123;student_age&#125;)</span></span></span><br><span class="line"><span class="function">&lt;/insert&gt;</span></span><br><span class="line"><span class="function">```java</span></span><br><span class="line"><span class="function"><span class="comment">// 方式二，使用 `&lt;selectKey /&gt;` 标签 + AFTER</span></span></span><br><span class="line"><span class="function">&lt;insert id</span>=<span class="string">"save"</span> parameterType=<span class="string">"com.threeti.to.ZoneTO"</span> &gt;</span><br><span class="line">    &lt;selectKey resultType=<span class="string">"java.lang.Long"</span> keyProperty=<span class="string">"id"</span> order=<span class="string">"AFTER"</span> &gt;</span><br><span class="line">      SELECT SEQ_ZONE.CURRVAL AS id FROM dual</span><br><span class="line">    &lt;/selectKey&gt;</span><br><span class="line">    </span><br><span class="line">    <span class="function">INSERT INTO <span class="title">TBL_ZONE</span> <span class="params">(ID, NAME )</span> </span></span><br><span class="line"><span class="function">    <span class="title">VALUES</span> <span class="params">(SEQ_ZONE.NEXTVAL, #&#123;name,jdbcType=VARCHAR&#125;)</span></span></span><br><span class="line"><span class="function">&lt;/insert&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="Mybatis-执行批量插入，能返回数据库主键列表吗？"><a href="#Mybatis-执行批量插入，能返回数据库主键列表吗？" class="headerlink" title="Mybatis 执行批量插入，能返回数据库主键列表吗？"></a>Mybatis 执行批量插入，能返回数据库主键列表吗？</h3><p>能<br>升级Mybatis版本到3.3.1。官方在这个版本中加入了批量新增返回主键id的功能<br>mapper.xml层代码</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><span class="line"><span class="xml"><span class="comment">&lt;!-- 批量新增 --&gt;</span>  </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"batchInsert"</span> <span class="attr">parameterType</span>=<span class="string">"java.util.List"</span> <span class="attr">useGeneratedKeys</span>=<span class="string">"true"</span> <span class="attr">keyProperty</span>=<span class="string">"id"</span> &gt;</span>  </span></span><br><span class="line"><span class="xml">    INSERT INTO  </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"t_shop_resource"</span> /&gt;</span>  </span></span><br><span class="line"><span class="xml">    (relation_id, summary_id, relation_type)  </span></span><br><span class="line"><span class="xml">    VALUES  </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">collection</span>=<span class="string">"list"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">item</span>=<span class="string">"shopResource"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span>  </span></span><br><span class="line"><span class="xml">        (  </span></span><br><span class="line"><span class="xml">            #</span><span class="template-variable">&#123;shopResource.relationId&#125;</span><span class="xml">, #</span><span class="template-variable">&#123;shopResource.summaryId&#125;</span><span class="xml">, #</span><span class="template-variable">&#123;shopResource.relationType&#125;</span><span class="xml">  </span></span><br><span class="line"><span class="xml">        )  </span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span>  </span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<figure class="highlight kotlin"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> List&lt;ShopResource&gt; batchinsertCallId(List&lt;ShopResource&gt; shopResourceList)&#123;  </span><br><span class="line">    <span class="keyword">this</span>.getSqlSession().insert(getStatement(SQL_BATCH_INSERT_CALL_ID), shopResourceList);  </span><br><span class="line">    <span class="keyword">return</span> shopResourceList;<span class="comment">// 重点介绍  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在mybatis3.3.1中，虽然加入了批量新增返回主键id的功能，但是它是这样运行的，在需要新增插入新元素集合对象时，它会需要参数对象，当执行完插入操作后，给之前的参数对象设置id值，也就是改变了需要插入对象集合中的元素的属性id值， 所以接收返回时，返回方法形参参数即可，同样的地址引用改变了内容，返回后的集合也是改变后的集合。</p>
<h3 id="在-Mapper-中如何传递多个参数"><a href="#在-Mapper-中如何传递多个参数" class="headerlink" title="在 Mapper 中如何传递多个参数?"></a>在 Mapper 中如何传递多个参数?</h3><ul>
<li><p>第一种，使用 Map 集合，装载多个参数进行传递。代码如下：</p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 调用方法</span></span><br><span class="line">Map&lt;<span class="keyword">String</span>, Object&gt; <span class="built_in">map</span> = <span class="keyword">new</span> HashMap();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"start"</span>, start);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">put</span>(<span class="string">"end"</span>, <span class="built_in">end</span>);</span><br><span class="line"><span class="keyword">return</span> studentMapper.selectStudents(<span class="built_in">map</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper 接口</span></span><br><span class="line"><span class="function">List&lt;Student&gt; <span class="title">selectStudents</span><span class="params">(Map&lt;<span class="keyword">String</span>, Object&gt; <span class="built_in">map</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Mapper XML 代码</span></span><br><span class="line">&lt;select id=<span class="string">"selectStudents"</span> parameterType=<span class="string">"Map"</span> resultType=<span class="string">"Student"</span>&gt;</span><br><span class="line">    SELECT * </span><br><span class="line">    FROM students </span><br><span class="line">    LIMIT #&#123;start&#125;, #&#123;<span class="built_in">end</span>&#125;</span><br><span class="line">&lt;/select&gt;</span><br></pre></td></tr></table></figure>
<p><strong>显然，这不是一种优雅的方式。</strong></p>
</li>
<li><p>第二种，保持传递多个参数，使用 @Param 注解。代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// 调用方法</span><br><span class="line"><span class="keyword">return</span> studentMapper.selectStudents(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">// Mapper 接口</span><br><span class="line">List&lt;Student&gt; selectStudents(@Param("start") <span class="type">Integer</span> <span class="keyword">start</span>, @Param("end") <span class="type">Integer</span> <span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">// Mapper <span class="type">XML</span> 代码</span><br><span class="line">&lt;<span class="keyword">select</span> id="selectStudents" resultType="Student"&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * </span><br><span class="line">    <span class="keyword">FROM</span> students </span><br><span class="line">    <span class="keyword">LIMIT</span> #&#123;<span class="keyword">start</span>&#125;, #&#123;<span class="keyword">end</span>&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>推荐使用这种方式。</strong> </p>
</li>
<li><p>第三种，保持传递多个参数，不使用 @Param 注解。代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">// 调用方法</span><br><span class="line"><span class="keyword">return</span> studentMapper.selectStudents(<span class="number">0</span>, <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">// Mapper 接口</span><br><span class="line">List&lt;Student&gt; selectStudents(<span class="type">Integer</span> <span class="keyword">start</span>, <span class="type">Integer</span> <span class="keyword">end</span>);</span><br><span class="line"></span><br><span class="line">// Mapper <span class="type">XML</span> 代码</span><br><span class="line">&lt;<span class="keyword">select</span> id="selectStudents" resultType="Student"&gt;</span><br><span class="line">    <span class="keyword">SELECT</span> * </span><br><span class="line">    <span class="keyword">FROM</span> students </span><br><span class="line">    <span class="keyword">LIMIT</span> #&#123;param1&#125;, #&#123;param2&#125;</span><br><span class="line">&lt;/<span class="keyword">select</span>&gt;</span><br></pre></td></tr></table></figure>
<p><strong>其中，按照参数在方法方法中的位置，从 1 开始，逐个为 #{param1}、#{param2}、#{param3} 不断向下。</strong></p>
</li>
</ul>
<h3 id="Mybatis-是否可以映射-Enum-枚举类？"><a href="#Mybatis-是否可以映射-Enum-枚举类？" class="headerlink" title="Mybatis 是否可以映射 Enum 枚举类？"></a>Mybatis 是否可以映射 Enum 枚举类？</h3><p>Mybatis 可以映射枚举类，对应的实现类为 EnumTypeHandler 或 EnumOrdinalTypeHandler 。</p>
<p>EnumTypeHandler ，基于 Enum.name 属性( String )。默认。<br>EnumOrdinalTypeHandler ，基于 Enum.ordinal 属性( int )。可通过 <setting name="defaultEnumTypeHandler" value="EnumOrdinalTypeHandler"> 来设置。<br>当然，实际开发场景，我们很少使用 Enum 类型，更加的方式是，代码如下：</setting></p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="symbol">Dog</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> STATUS_GOOD = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> STATUS_BETTER = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> static <span class="keyword">final</span> <span class="built_in">int</span> STATUS_BEST = <span class="number">3</span>；</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="built_in">int</span> status;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>并且，不单可以映射枚举类，Mybatis 可以映射任何对象到表的一列上。映射方式为自定义一个 TypeHandler 类，实现 TypeHandler 的#setParameter(…) 和 #getResult(…) 接口方法。</p>
<p>TypeHandler 有两个作用：</p>
<p>一是，完成从 javaType 至 jdbcType 的转换。<br>二是，完成 jdbcType 至 javaType 的转换。<br>具体体现为 #setParameter(…) 和 #getResult(..) 两个方法，分别代表设置 SQL 问号占位符参数和获取列查询结果。</p>
<h3 id="Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？"><a href="#Mybatis-都有哪些-Executor-执行器？它们之间的区别是什么？" class="headerlink" title="Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？"></a>Mybatis 都有哪些 Executor 执行器？它们之间的区别是什么？</h3><p>Mybatis 有四种 Executor 执行器，分别是 SimpleExecutor、ReuseExecutor、BatchExecutor、CachingExecutor 。</p>
<p>SimpleExecutor ：每执行一次 update 或 select 操作，就创建一个 Statement 对象，用完立刻关闭 Statement 对象。<br>ReuseExecutor ：执行 update 或 select 操作，以 SQL 作为key 查找缓存的 Statement 对象，存在就使用，不存在就创建；用完后，不关闭 Statement 对象，而是放置于缓存 Map&lt;String, Statement&gt; 内，供下一次使用。简言之，就是重复使用 Statement 对象。<br>BatchExecutor ：执行 update 操作（没有 select 操作，因为 JDBC 批处理不支持 select 操作），将所有 SQL 都添加到批处理中（通过 addBatch 方法），等待统一执行（使用 executeBatch 方法）。它缓存了多个 Statement 对象，每个 Statement 对象都是调用 addBatch 方法完毕后，等待一次执行 executeBatch 批处理。实际上，整个过程与 JDBC 批处理是相同。<br>CachingExecutor ：在上述的三个执行器之上，增加二级缓存的功能。</p>
<p><code>通过设置 &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;&quot;&gt; 的 &quot;value&quot; 属性，可传入 SIMPLE、REUSE、BATCH 三个值，分别使用 SimpleExecutor、ReuseExecutor、BatchExecutor 执行器。</code></p>
<p><code>通过设置 &lt;setting name=&quot;cacheEnabled&quot; value=&quot;&quot; 的 &quot;value&quot; 属性为 true 时，创建 CachingExecutor 执行器。</code></p>
<h3 id="MyBatis-如何执行批量插入"><a href="#MyBatis-如何执行批量插入" class="headerlink" title="MyBatis 如何执行批量插入?"></a>MyBatis 如何执行批量插入?</h3><p>首先，在 Mapper XML 编写一个简单的 Insert 语句。代码如下：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">&lt;<span class="keyword">insert</span> id="insertUser" parameterType="String"&gt; </span><br><span class="line">    <span class="keyword">INSERT</span> <span class="keyword">INTO</span> users(<span class="type">name</span>) </span><br><span class="line">    <span class="keyword">VALUES</span> (#&#123;<span class="keyword">value</span>&#125;) </span><br><span class="line">&lt;/<span class="keyword">insert</span>&gt;</span><br></pre></td></tr></table></figure>
<p>然后，然后在对应的 Mapper 接口中，编写映射的方法。代码如下：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">public</span> <span class="selector-tag">interface</span> <span class="selector-tag">UserMapper</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="selector-tag">void</span> <span class="selector-tag">insertUser</span>(<span class="variable">@Param</span>(<span class="string">"name"</span>) String name);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，调用该 Mapper 接口方法。代码如下：</p>
<figure class="highlight processing"><table><tr><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">@Test</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> testBatch() &#123;</span><br><span class="line">    <span class="comment">// 创建要插入的用户的名字的数组</span></span><br><span class="line">    List&lt;<span class="keyword">String</span>&gt; names = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    names.<span class="built_in">add</span>(<span class="string">"占小狼"</span>);</span><br><span class="line">    names.<span class="built_in">add</span>(<span class="string">"朱小厮"</span>);</span><br><span class="line">    names.<span class="built_in">add</span>(<span class="string">"徐妈"</span>);</span><br><span class="line">    names.<span class="built_in">add</span>(<span class="string">"飞哥"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得执行器类型为 Batch 的 SqlSession 对象，并且 autoCommit = false ，禁止事务自动提交</span></span><br><span class="line">    <span class="keyword">try</span> (SqlSession session = sqlSessionFactory.openSession(ExecutorType.BATCH, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="comment">// 获得 Mapper 对象</span></span><br><span class="line">        UserMapper mapper = session.getMapper(UserMapper.class);</span><br><span class="line">        <span class="comment">// 循环插入</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">String</span> name : names) &#123;</span><br><span class="line">            mapper.insertUser(name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 提交批量操作</span></span><br><span class="line">        session.commit();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>还有另一种方式，代码如下：<figure class="highlight markdown"><table><tr><td class="code"><pre><span class="line">INSERT INTO [<span class="string">表名</span>](<span class="link">[列名],[列名]</span>) </span><br><span class="line">VALUES</span><br><span class="line">([列值],[列值])),</span><br><span class="line">([列值],[列值])),</span><br><span class="line">([列值],[列值]));</span><br></pre></td></tr></table></figure>
对于这种方式，需要保证单条 SQL 不超过语句的最大限制 max_allowed_packet 大小，默认为 1 M 。<br>这两种方式的性能对比，可以看看 <a href="https://www.jianshu.com/p/cce617be9f9e" target="_blank" rel="noopener">《[实验]mybatis批量插入方式的比较》 </a>。</li>
</ul>
<h3 id="介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？"><a href="#介绍-MyBatis-的一级缓存和二级缓存的概念和实现原理？" class="headerlink" title="介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？"></a>介绍 MyBatis 的一级缓存和二级缓存的概念和实现原理？</h3><h3 id="Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？"><a href="#Mybatis-是否支持延迟加载？如果支持，它的实现原理是什么？" class="headerlink" title="Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？"></a>Mybatis 是否支持延迟加载？如果支持，它的实现原理是什么？</h3><p>Mybatis 仅支持 association 关联对象和 collection 关联集合对象的延迟加载。其中，association 指的就是一对一，collection 指的就是一对多查询。</p>
<p>在 Mybatis 配置文件中，可以配置 <setting name="lazyLoadingEnabled" value="true"> 来启用延迟加载的功能。默认情况下，延迟加载的功能是关闭的。</setting></p>
<p>它的原理是，使用 CGLIB 或 Javassist( 默认 ) 创建目标对象的代理对象。当调用代理对象的延迟加载属性的 getting 方法时，进入拦截器方法。比如调用 a.getB().getName() 方法，进入拦截器的 invoke(…) 方法，发现 a.getB() 需要延迟加载时，那么就会单独发送事先保存好的查询关联 B 对象的 SQL ，把 B 查询上来，然后调用a.setB(b) 方法，于是 a 对象 b 属性就有值了，接着完成a.getB().getName() 方法的调用。这就是延迟加载的基本原理。</p>
<p>当然了，不光是 Mybatis，几乎所有的包括 Hibernate 在内，支持延迟加载的原理都是一样的。</p>
<h3 id="Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"><a href="#Mybatis-能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。" class="headerlink" title="Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。"></a>Mybatis 能否执行一对一、一对多的关联查询吗？都有哪些实现方式，以及它们之间的区别。</h3><p>能，Mybatis 不仅可以执行一对一、一对多的关联查询，还可以执行多对一，多对多的关联查询。</p>
<ul>
<li><p>一对多<br>用户级联文章在JavaBean中的编写方式,这就是一对多在JavaBean中的配置<br><img src="/.io//02.png" alt="02.png"><br>Mybatis的Mapper该如何编写一对多?很简单,就是在resultMap标签中配置<collection>标签,用来存储查询到的文章列表,注意posts代表的是用户实体的文章List集合<br><img src="/.io//03.png" alt="03.png"></collection></p>
</li>
<li><p>多对一<br>文章级联用户在JavaBean中的编写方式,这是多对一在JavaBean中的配置<br><img src="/.io//04.png" alt="04.png"><br>Mybatis的Mapper该如何编写多对一?很简单,就是在resultMap标签中配置<association></association>标签关联所属的用户实体<br><img src="/.io//05.png" alt="05.png"></p>
</li>
</ul>
<h3 id="简述-Mybatis-的插件运行原理？以及如何编写一个插件？"><a href="#简述-Mybatis-的插件运行原理？以及如何编写一个插件？" class="headerlink" title="简述 Mybatis 的插件运行原理？以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</h3><p>Mybatis 仅可以编写针对 ParameterHandler、ResultSetHandler、StatementHandler、Executor 这 4 种接口的插件。</p>
<p>Mybatis 使用 JDK 的动态代理，为需要拦截的接口生成代理对象以实现接口方法拦截功能，每当执行这 4 种接口对象的方法时，就会进入拦截方法，具体就是 InvocationHandler 的 #invoke(…)方法。当然，只会拦截那些你指定需要拦截的方法。</p>
<p>编写一个 MyBatis 插件的步骤如下：</p>
<ul>
<li>首先，实现 Mybatis 的 Interceptor 接口，并实现 #intercept(…) 方法。</li>
<li>然后，在给插件编写注解，指定要拦截哪一个接口的哪些方法即可</li>
<li>最后，在配置文件中配置你编写的插件。</li>
</ul>
<h3 id="简述-Mybatis-的插件运行原理？以及如何编写一个插件？-1"><a href="#简述-Mybatis-的插件运行原理？以及如何编写一个插件？-1" class="headerlink" title="简述 Mybatis 的插件运行原理？以及如何编写一个插件？"></a>简述 Mybatis 的插件运行原理？以及如何编写一个插件？</h3><p>Mybatis 使用 RowBounds 对象进行分页，它是针对 ResultSet 结果集执行的内存分页，而非数据库分页。<br>所以，实际场景下，不适合直接使用 MyBatis 原有的 RowBounds 对象进行分页。而是使用如下两种方案：</p>
<p>在 SQL 内直接书写带有数据库分页的参数来完成数据库分页功能<br>也可以使用分页插件来完成数据库分页。<br>这两者都是基于数据库分页，差别在于前者是工程师手动编写分页条件，后者是插件自动添加分页条件。</p>
<p>分页插件的基本原理是使用 Mybatis 提供的插件接口，实现自定义分页插件。在插件的拦截方法内，拦截待执行的 SQL ，然后重写 SQL ，根据dialect 方言，添加对应的物理分页语句和物理分页参数。</p>
<p>举例：SELECT * FROM student ，拦截 SQL 后重写为：select * FROM student LIMI 0，10 。</p>
<h3 id="MyBatis-与-Hibernate-有哪些不同？"><a href="#MyBatis-与-Hibernate-有哪些不同？" class="headerlink" title="MyBatis 与 Hibernate 有哪些不同？"></a>MyBatis 与 Hibernate 有哪些不同？</h3><ul>
<li>hibernate是全自动，而mybatis是半自动<br>hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。而mybatis仅有基本的字段映射，对象数据以及对象实际关系仍然需要通过手写sql来实现和管理。</li>
<li>hibernate数据库移植性远大于mybatis<br>hibernate通过它强大的映射结构和hql语言，大大降低了对象与数据库（oracle、mysql等）的耦合性，而mybatis由于需要手写sql，因此与数据库的耦合性直接取决于程序员写sql的方法，如果sql不具通用性而用了很多某数据库特性的sql语句的话，移植性也会随之降低很多，成本很高。</li>
<li>hibernate拥有完整的日志系统，mybatis则欠缺一些<br>hibernate日志系统非常健全，涉及广泛，包括：sql记录、关系异常、优化警告、缓存提示、脏数据警告等；而mybatis则除了基本记录功能外，功能薄弱很多。</li>
<li>mybatis相比hibernate需要关心很多细节<br>hibernate配置要比mybatis复杂的多，学习成本也比mybatis高。但也正因为mybatis使用简单，才导致它要比hibernate关心很多技术细节。mybatis由于不用考虑很多细节，开发模式上与传统jdbc区别很小，因此很容易上手并开发项目，但忽略细节会导致项目前期bug较多，因而开发出相对稳定的软件很慢，而开发出软件却很快。hibernate则正好与之相反。但是如果使用hibernate很熟练的话，实际上开发效率丝毫不差于甚至超越mybatis。</li>
<li>sql直接优化上，mybatis要比hibernate方便很多<br>由于mybatis的sql都是写在xml里，因此优化sql比hibernate方便很多。而hibernate的sql很多都是自动生成的，无法直接维护sql；虽有hql，但功能还是不及sql强大，见到报表等变态需求时，hql也歇菜，也就是说hql是有局限的；hibernate虽然也支持原生sql，但开发模式上却与orm不同，需要转换思维，因此使用上不是非常方便。总之写sql的灵活度上hibernate不及mybatis。</li>
</ul>
<h3 id="JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？"><a href="#JDBC-编程有哪些不足之处，MyBatis是如何解决这些问题的？" class="headerlink" title="JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？"></a>JDBC 编程有哪些不足之处，MyBatis是如何解决这些问题的？</h3><p>问题一：SQL 语句写在代码中造成代码不易维护，且代码会比较混乱。<br>解决方式：将 SQL 语句配置在 Mapper XML 文件中，与 Java 代码分离。</p>
<p>问题二：根据参数不同，拼接不同的 SQL 语句非常麻烦。例如 SQL 语句的 WHERE 条件不一定，可能多也可能少，占位符需要和参数一一对应。<br>解决方式：MyBatis 提供 <where>、<if> 等等动态语句所需要的标签，并支持 OGNL 表达式，简化了动态 SQL 拼接的代码，提升了开发效率。</if></where></p>
<p>问题三，对结果集解析麻烦，SQL 变化可能导致解析代码变化，且解析前需要遍历。<br>解决方式：Mybatis 自动将 SQL 执行结果映射成 Java 对象。</p>
<p>问题四，数据库链接创建、释放频繁造成系统资源浪费从而影响系统性能，如果使用数据库链接池可解决此问题。<br>解决方式：在 mybatis-config.xml 中，配置数据链接池，使用连接池管理数据库链接。<br>当然，即使不使用 MyBatis ，也可以使用数据库连接池。<br>另外，MyBatis 默认提供了数据库连接池的实现，只是说，因为其它开源的数据库连接池性能更好，所以一般很少使用 MyBatis 自带的连接池实现。</p>
<h3 id="Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？"><a href="#Mybatis-映射文件中，如果-A-标签通过-include-引用了B标签的内容，请问，B-标签能否定义在-A-标签的后面，还是说必须定义在A标签的前面？" class="headerlink" title="Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？"></a>Mybatis 映射文件中，如果 A 标签通过 include 引用了B标签的内容，请问，B 标签能否定义在 A 标签的后面，还是说必须定义在A标签的前面？</h3><p>虽然 Mybatis 解析 XML 映射文件是按照顺序解析的。但是，被引用的 B 标签依然可以定义在任何地方，Mybatis 都可以正确识别。也就是说，无需按照顺序，进行定义。</p>
<p>原理是，Mybatis 解析 A 标签，发现 A 标签引用了 B 标签，但是 B 标签尚未解析到，尚不存在，此时，Mybatis 会将 A 标签标记为<strong>未解析状态</strong>。然后，继续解析余下的标签，包含 B 标签，待所有标签解析完毕，Mybatis 会重新解析那些被标记为未解析的标签，此时再解析A标签时，B 标签已经存在，A 标签也就可以正常解析完成了</p>
<h3 id="简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？"><a href="#简述-Mybatis-的-XML-映射文件和-Mybatis-内部数据结构之间的映射关系？" class="headerlink" title="简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？"></a>简述 Mybatis 的 XML 映射文件和 Mybatis 内部数据结构之间的映射关系？</h3><p>Mybatis 将所有 XML 配置信息都封装到 All-In-One 重量级对象Configuration内部。<br>在 XML Mapper 文件中：<br><code>&lt;parameterMap&gt; 标签，会被解析为 ParameterMap 对象，其每个子元素会被解析为 ParameterMapping 对象。</code><br><code>&lt;resultMap&gt; 标签，会被解析为 ResultMap 对象，其每个子元素会被解析为 ResultMapping 对象。</code><br><code>每一个 &lt;select&gt;、&lt;insert&gt;、&lt;update&gt;、&lt;delete&gt; 标签，均会被解析为一个 MappedStatement 对象，标签内的 SQL 会被解析为一个 BoundSql 对象。</code></p>
]]></content>
      <categories>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
</search>
